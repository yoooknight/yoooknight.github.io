title: 商城实战总结：搭建底层框架(二)
date: 2016-02-21 09:12:21
tags: [PHP,十八哥,BOOL商城]
categories: [PHP学习记录]
---

> 框架额外功能的补充:
1. 日志类
2. 数据库类

<!--more-->
# 一、日志类
> 这里直接上代码:

## 代码
``` php
Class Log{
	const LOG = 'curr.log';//将日志文件名字保存在常量中

	Public Static function write($cont){
		// 要用双引号,转义,单引号会直接输出
		$cont .= "\r\n";
		// 判断日志文件的路径在哪里
		// 日志是否备份
		$log = self::is_bak();

		// 写入日志中
		$fh = fopen($log,'rb');//打开文本资源,以二进制追加的方式写入
		$fwrite($fh,$cont);//向资源中写入内容
		fclose($fh);//关闭该资源
	}

	/**
	 * [bak 备份日志文件]
	 * @return {[type]} [description]
	 */
	Public Static function bak($log){
		// 备份文件名(日期+随机数)
		$bak = ROOT.'data/log/'.date('ymd').mt_rand(100000,999999).'.bak';
		return rename($log,$bak);
	}

	/**
	 * [is_bak 检测是否备份]
	 * @return {string} [返回日志路径]
	 */
	Public Static function is_bak(){
		// 拼接日志路径
		$log = ROOT.'data/log'.self::LOG;
		// 判断该路径是否存在
		if(!file_exists($log)){
			touch($log);
			return $log;
		}
		// 判断文件夹大小
		$size = filesize($log);
		if($size <= 1024*1024){//小于1m,就继续使用该文件
			return $log;
		}

		// 如果走到了这一步,说明该备份了
		if(self::bak($log)){// 返回true,说明备份成功,需要重新创建日志文件
			touch($log);
		}
		// 返回日志文件
		return $log;
	}
}
```

# 二、数据库类
> 不多说,根据(一)中的db数据库抽象类,写出数据库操作类
因为数据库,只需要实例化一次,多了会资源会浪费,所以使用单例模式

## 代码:
``` php
	Class mysql extends db{
		Private static $ins = null; //对象
		Private $conn = null; //数据库连接对象
		Private $conf = array(); //配置文件

		/**
		 * [__construct 通过配置文件连接数据库]
		 */
		final Protected function __construct(){
			// 从配置文件中取出数据
			$this->conf = config::getIns();

			//链接数据库
			$this->connect($this->conf->DB_HOST,$this->conf->DB_USER,$this->conf->DB_PWD,$this->conf->DB_NAME);
		}


		/**
		 * [connect 连接数据库]
		 * @param  {[type]} $h [服务器]
		 * @param  {[type]} $u [用户名]
		 * @param  {[type]} $p [密码]
		 * @param  {[type]} $d [数据库]
		 */
		Public function connect($h,$u,$p,$d){
			$this->conn = new mysqli($h,$u,$p,$d);
			if($this->conn->connect_error){
				LOG::write($this->conn->connect_error);
				die('连接失败');
			}
		}

		// 实例化对象
		Public Static function getIns(){
			if(!(self::$ins instanceof self)){
				self::$ins = new self();
			}
			return self::$ins;
		}

		// 发送查询
		Public function query($sql){
			$rs = $this->conn->query($sql);
			LOG::write($sql);
			return $rs;
		}

		// 自动执行
		Public function autoExecute($table,$data,$action='insert',$where=''){
			if($action == 'insert'){
				$sql = 'INSERT INTO '.$table.'('.implode(',',array_keys($data)).')';
				$sql .= 'VALUES (\'';
				$sql .= implode("','",array_values($data));
				$sql .= ')\'';
			}else{
				$sql = 'UPDATE '.$table.' SET ';
				foreach($data as $k=>$v){
					$sql .= $k."='".$v."',";
				}
			}
			// 删除字符串末端的空白字符
			// $sql =rtrim($sql,',');
			$sql .= $where;
			return $this->query($sql);
		}


		// 查询多行数据
		Public function getAll($sql){
			$rs = $this->query($sql);
			$list = array();
			while($row = rs->fetch_assoc()){
				$list[] = $row;
			}
			return $list;
		}

		// 查询单行数据
		Public function getRow($sql){
			$rs = $this->query($sql);
			// fetch_assoc是取下标是关联数组
			return $row = $rs->fetch_assoc();
		}

		// 查询单个数据
		Public function getOne($sql){
			$rs = $this->query($sql);

			// fetch_row是取出下标是数字
			$row = $rs->fetch_row();

			return $row[0];
		}

		// 返回影响行
		// 当时删除操作时,只有通过影响行来判断是否成功
		Public function affected_rows(){
			return $this->conn->affected_rows;
		}

		// 返回插入数据id
		Public function insert_id(){
			return $this->conn->insert_id;
		}

		// 克隆
		Public function __clone(){
			die();
		}
 	}
```