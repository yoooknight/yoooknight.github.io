title: 商城实战总结：搭建底层框架(一)
date: 2016-02-18 09:47:33
tags: [PHP,十八哥,BOOL商城]
categories: [PHP学习记录]
---

> 框架的结构:
1. init.php(初始化框架)
2. config.inc.php(配置文件的基本信息)
3. config.class.php(读取配置文件的类):单例模式
4. db.class.php(数据库类)

<!--more-->
# 一、init.php开发：
功能:
1.设置目录常量
2.自动加载引入基本类库
3.过滤参数
4.报错级别设置
5.权限控制


## 1. 设置目录常量
``` php
// 通过__FILE__获取init.php的路径
// 因为//在windows,和linux都可以用,所以要将\\替换成/
defined('ROOT') || define('ROOT',str_replace('\\','/',dirname(dirname(__FILE__))).'/');
```
## 2. 自动加载引入基本类库
``` php
// 自动加载的方法来引入
function Boolautoload($class){
	//因为Model的命名规则是:xxxModel.class.php,类名就是xxxModel
	if(strtolower(substr($class,-5)) == 'Model'){
		require(ROOT.'Model/'.$class.'.class.php');
	}elseif(strtolower(substr($class,-4)) == 'tool'){
		//同样的,工具类也是这样命名的
		require(ROOT.'Tool/'.$class.'.class.php');
	}else{
		require(ROOT.'include/'.$class.'.class.php');
	}
}

//注册自动加载
spl_autoload_register('Boolautoload');

//注:这里之所以用自动注册,是为了防止引入其他工具smarty也有自动加载函数,这样就会被覆盖,注册就不会产生这些问题;
```
## 3. 过滤参数
这里要用到递归的知识点;
注:过滤数据的时候最好不要用htmlspecialchars处理
因为当出现<>这些html标签的时候就不能正常显示了
``` php
	function __addslashes($arr){
		//遍历传过来的数组
		foreach($arr as $k=>$v){
			if(is_array($v)){
				// 递归处理数组
				$arr[$k] = __addslashes[$v];
			}elseif(is_string($v)){
				// 
				$arr[$k] = addslashes($k);
			}
		}
		return $arr;
	}
```

## 4. 报错级别设置
``` php
	报错级别
	// 通过变量设置debug的默认状态为上线状态
	$debug = defined('DEBUG')?DEBUG:null;
	if($debug){
		error_reporting(E_ALL & ~E_NOTICE);
	}else{
		error_reporting(0);
	}
```
## 5. 权限控制
``` php
	// 不能直接访问的页面就添加
	defined('ACC') || exit('ACC DENIED');
	/** 
	 * 所以:访问init之前,要先定义ACC
	 * 当你从正常页面访问的时候,他会给你一把ACC钥匙
	 * 非法途径会exit退出
	 */
```
# 二、config配置文件

## config.inc.php
> 这个函数的作用是写入配置数据,供其他页面调用;
``` php
	// 示例:数据库的配置信息
	$_CONF = array(
		'DB_HOST'=>'localhost',
		'DB_USER'=>'root',
		'DB_PWD'=>'',
		'DB_NAME'=>'bool',
	)
```

## config.class.php
> 这个函数是调用配置数据的;
> 分析:
0.当只有一个类调用的时候就可以直接调用inc.php
2.当多个类都来调用的时候,会很乱
3.所以需要一个config.class.php来统一一次性将配置信息都进来,所有的类再需要配置信息,都找conf类
4.配置文件的类需要保持一致,让每个来读取的类都是同一个对象,所以采用单例模式

``` php
	
	Class config{

		// 保存对象
		Protected static $ins = null;
		// 配置文件
		Public $data = array();

		// 阻止在外部实例化
		final protected function __construct(){
			// 引入配置文件
			// 一次性把配置文件读取过来,并且赋值给data
			require(ROOT.'include/config.inc.php');
			$this->data = $_CONF;
		}
		// 阻止克隆,产生新的对象
		protected function __clone(){

		}

		public static function getIns(){
			if(!(self::$ins instanceof self)){
				self::$ins = new self();
			}
			return self::$ins;
		}

		// 获取配置文件数据
		Public function __get($key){
			if(array_key_exists($key,$this->data)){
				return $this->data[$key];
			}else{
				return null;
			}
		}

		// 可以添加修改配置文件中的数据
		Public function __set($key,$value){
			return $this->data[$key] = $value;
		}
	}
```

# 三、db数据库类
> 分析:
1.目前到底采用什么数据库,还不清楚
2.但是每个数据库的基本功能必须要有
3.所以先写一个抽象类

``` php
abstract class db{
	// 链接服务器
	public abstract function connect($h,$u,$p);

	// 发送查询
	public abstract function query($sql);

	// 查询多行数据
	public abstract function getAll($sql);

	// 查询单行数据
	public abstract function getRow($sql);	

	// 查询单个数据
	public abstract function getOne($sql);

	// 自动执行,insert/update
	public abstract function autoExecute($table,$data,$act = 'insert',$where = '');
}
```